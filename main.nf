#!/usr/bin/env nextflow

nextflow.enable.dsl = 2

if ( params.readDIR == null ) {
  exit 0, "ERROR: readDIR must be specified."
}

if ( params.target == null ) {
  exit 0, "ERROR: target must be specified."
}

// Expand user directory if exists
outDIR = "${params.outDIR}".replaceFirst("^~", System.getProperty("user.home"))
readDIR = "${params.readDIR}".replaceFirst("^~", System.getProperty("user.home"))

// Set boilerplate parameters
params.QC_only         = false
params.reads           = "${readDIR}/*_R{1,2}*.fastq.gz"
params.amplicon_info   = "$projectDir/resources/${params.target}/${params.target}_amplicon_info.tsv"
params.scriptDIR       = "$projectDir/R_code"
// pf3D7_index            = "$projectDir/resources/${params.target}/3D7_ampseq"
// codontable             = "$projectDir/resources/${params.target}/codontable.txt"
params.resmarkers_amplicon    = "$projectDir/resources/${params.target}/resistance_markers_amplicon_${params.target}.txt"
params.codontable      = "$projectDir/templates/codontable.txt"

// Files

cutadapt_minlen = params.cutadapt_minlen

/*
Create 'read_pairs' channel that emits for each read pair a
tuple containing 3 elements: pair_id, R1, R2
*/

include { CREATE_PRIMER_FILES } from './modules/local/create_primer_files.nf'
include { CUTADAPT } from './modules/local/cutadapt.nf'
include { QUALITY_REPORT } from './modules/local/quality_report.nf'
include { DADA2_ANALYSIS } from './modules/local/dada2_analysis.nf'
include { COLLAPSE_CONCATENATED_READS } from './modules/local/collapse_concatenated_reads.nf'
include { MASK_SEQUENCES } from './modules/local/mask_sequences.nf'
include { MASK_REFERENCE_TANDEM_REPEATS } from './modules/local/mask_reference_tandem_repeats.nf'
include { ALIGN_TO_REFERENCE } from './modules/local/align_to_reference.nf'
include { CREATE_REFERENCE_FROM_GENOMES } from './modules/local/create_reference_from_genomes.nf'

workflow DEMULTIPLEX_AMPLICONS {

  take: 
  read_pairs

  main:
  CREATE_PRIMER_FILES(params.amplicon_info)
  CUTADAPT(
    CREATE_PRIMER_FILES.out.fwd_primers,
    CREATE_PRIMER_FILES.out.rev_primers,
    read_pairs,
    params.cutadapt_minlen,
    params.sequencer,
    params.allowed_errors,
    params.cutadapt_cores
  )

  emit:
  sample_summary_ch = CUTADAPT.out.sample_summary
  amplicon_summary_ch = CUTADAPT.out.amplicon_summary
  demux_fastqs_ch = CUTADAPT.out.demultiplexed_fastqs
}

workflow QUALITY_CONTROL {
  
  take:
  sample_summary_ch
  amplicon_summary_ch

  main:
  QUALITY_REPORT(
    sample_summary_ch.collect(),
    amplicon_summary_ch.collect(),
    params.amplicon_info,
    params.qc_cores
  )
}

workflow DENOISE_AMPLICONS {

  take:
  demultiplexed_fastqs

  main:

  DADA2_ANALYSIS(
    demultiplexed_fastqs.collect(),
    params.amplicon_info,
    params.pool,
    params.band_size,
    params.omega_a,
    params.maxEE,
    params.just_concatenate
  )

  // Custom code to further denoise sequences
  // generated by DADA2
  if (params.just_concatenate) {
    COLLAPSE_CONCATENATED_READS(
      DADA2_ANALYSIS.out.dada2_clusters
    )
  }

  emit: 
  denoise_ch = params.just_concatenate ? 
    COLLAPSE_CONCATENATED_READS.out.clusters_concatenated_collapsed : 
    DADA2_ANALYSIS.out.dada2_clusters
}

workflow PREPARE_REFERENCE_SEQUENCES {

  main:
  if (params.genome != null) {
    CREATE_REFERENCE_FROM_GENOMES(
      params.genome,
      params.amplicon_info,
      "${params.target}_reference.fasta" // could allow this to be customizable
    )
  }

  emit:
  reference_ch = (params.refseq_fasta == null) ? 
    CREATE_REFERENCE_FROM_GENOMES.out.reference_fasta :
    params.refseq_fasta
}

workflow DENOISE_AMPLICONS_2 {

  take: 
  denoise_ch

  main:

  // create a fasta with reference sequences that are specified
  // by the amplicon panel. if one is supplied, then the workflow
  // will just return it.
  PREPARE_REFERENCE_SEQUENCES()

  ALIGN_TO_REFERENCE(
    denoise_ch,
    PREPARE_REFERENCE_SEQUENCES.out.reference_ch,
    params.amplicon_info,
    params.parallel,
    params.n_cores
  )

  // optionally mask sequences
  // note: could break this down into mask tr / homop processes or keep it as one
  if (params.masked_fasta == null) {
    def maskScore = params.add_mask ? params.trf_min_score : 0
    def maskPeriod = params.add_mask ? params.trf_max_period : 0

    MASK_REFERENCE_TANDEM_REPEATS(
      PREPARE_REFERENCE_SEQUENCES.out.reference_ch,
      params.trf_min_score,
      params.trf_max_period
    )
  }

  def homopolymer_threshold = params.homopolymer_threshold ? params.homopolymer_threshold : 0

  MASK_SEQUENCES(
    ALIGN_TO_REFERENCE.out.alignments,
    (params.masked_fasta == null) ? MASK_REFERENCE_TANDEM_REPEATS.out.masked_fasta : params.masked_fasta,
    params.amplicon_info,
    params.parallel,
    params.n_cores
  )

  emit:
  masked_allele_data_ch = MASK_SEQUENCES.out.allele_data
}

workflow {
  read_pairs = channel.fromFilePairs( params.reads, checkIfExists: true )
  DEMULTIPLEX_AMPLICONS(read_pairs)
  if (params.QC_only == true) {

    // create a quality report with the raw data
    QUALITY_CONTROL(
      DEMULTIPLEX_AMPLICONS.out.sample_summary_ch,
      DEMULTIPLEX_AMPLICONS.out.amplicon_summary_ch
    )

    // exit here
    return
  }

  DENOISE_AMPLICONS(
    DEMULTIPLEX_AMPLICONS.out.demux_fastqs_ch
  )

  DENOISE_AMPLICONS_2(
    DENOISE_AMPLICONS.out.denoise_ch
  )
}

